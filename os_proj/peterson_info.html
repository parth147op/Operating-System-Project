<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peterson Method</title>
    <link rel="stylesheet" href="peterson_info.css" />
    <link rel="icon" href="images/logo1.png" />
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/fontawesome.min.css"
        integrity="sha384-jLKHWM3JRmfMU0A5x5AkjWkw/EYfGUAGagvnfryNV3F9VqM98XiIH7VBGVoxVSc7" crossorigin="anonymous" />
    <script src="https://kit.fontawesome.com/61820eb66c.js" crossorigin="anonymous"></script>
</head>

<body>
    <header>
        <a href="index.html" class="logo">Deadlock And Concurrency</a>
        <div class="toggle" onclick="toggleMenu();"></div>
        <ul class="menu">
            <li><a href="#page_top" onclick="toggleMenu();">Home</a></li>
            <li><a href="#about" onclick="toggleMenu();">About</a></li>
            <li><a href="index.html" onclick="toggleMenu();">Algorithms</a></li>
        </ul>
    </header>

    <section class="info" id="page_top">
        <h1>Peterson Method</h1>
        <h2>Introduction:</h2>
        <p>Peterson's solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting. Peterson's algorithm is considered a standard low-level algorithm for two-thread mutual exclusion.
        
        <h2>P0 execution</h2>    
        <ul>
            <li>Process P0 is initiated and has entered the Start state.</li>
            <li>Process P0 after a certain instant of time, enters Critical section.</li>
            <li>Since, Critical section is already occupied by Process P0, it is now time to trigger Process P1.</li>
        </ul>
    


        <h2>P1 Trigger</h2>
       
        <ul>
            <li>Process P1 is triggered.</li>
            <li>Process P1 awaits in Start state as Critical section is already occupied by Process P0.</li>
            <li>Process P0 has exited the Critical section and hence, Process P1 can now enter the Critical state.</li>
            <li>Process P1 enters the Critical section, meanwhile Process P0 executes and enters the Exit state.</li>
            <li>Process P1 exits the Critical section and executes to enter the Exit state and meanwhile Process P0 has completed.</li>
            <li>Process P1 has completed.</li>
        </ul>
        
        <h2>Analysis of Peterson Algorithm approach</h2>
        <ul>
            <li>
                Mutual Exclusion:
                <p>The method provides mutual exclusion for sure. In entry section, the while condition involves the criteria for two variables therefore a process cannot enter in the critical section until the other process is interested and the process is the last one to update turn variable.</p>
            </li>
            <li>
                Progress:
                <p>An uninterested process will never stop the other interested process from entering in the critical section. If the other process is also interested then the process will wait.</p>
            </li>
            <li>
                Bounded waiting:
                <p>The interested variable mechanism failed because it was not providing bounded waiting. However, in Peterson solution, A deadlock can never happen because the process which first sets the turn variable will enter in the critical section for sure.</p>
            </li>
            <li>
                Portability:
                <p>This is the complete software solution and therefore it is portable on every hardware.</p>
            </li>
        </ul>
    </section>



    <a href="/Peterson-Algorithm/peterson_meth.html"><button class="btn">Demo</button></a>


    <script type="text/javascript">
        window.addEventListener("scroll", function () {
            var header = document.querySelector("header");
            header.classList.toggle("sticky", window.scrollY > 0);
        });
        function toggleMenu() {
            var menuToggle = document.querySelector(".toggle");
            var menu = document.querySelector(".menu");
            menuToggle.classList.toggle("active");
            menu.classList.toggle("active");
        }
    </script>
</body>

</html>